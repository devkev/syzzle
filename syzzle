# .syzzle

if [ "${SYZ_SOURCE+set}" = set ]; then
	return
fi
SYZ_SOURCE="${BASH_SOURCE[0]}"
# FIXME: use a hash of the file contents instead
SYZ_SOURCED_AT="$(date +%s)"

SYZ_VERSION=0.0.1



# FIXME: test suite which exercises all the user-facing functions


##################################################
##
##  External (user facing) functions
##
##################################################


function syz {
	if ! __syz::__rerun_if_updated "$@"; then
		syz::dispatch "$@"
	fi
}


function sw {
	syz "$@"
}


function syz::dispatch {
	local cmd="$1" ; shift
	# FIXME: call syz::empty if cmd is empty
	# FIXME: call syz::unknown if syz_$cmd doesn't exist
	syz::"$cmd" "$@"
}


# Default function when an unknown sub-command is attempted to be run
function syz::unknown {
	# FIXME: customisable action
	# FIXME: better error message if syz_$cmd doesn't exist
	# FIXME: default action if syz_$cmd doesn't exist should be "load", eg. "syz mongodb/2.6.11" equiv to "syz load mongodb/2.6.11"
	syz::load "$@"
}


# Default function when just "syz" is run
function syz:: {
	syz::empty
}


function syz::empty {
	# FIXME: customisable action
	syz::show
}


function syz::show {
	syz::status "$@"
}


function syz::status {
	echo
	syz::version
	echo

	syz::loaded "$@"

	if [ "$SYZ_INACTIVE_MODULES" ]; then
		syz::inactive "$@"
	fi
}


function syz::loaded {
	# FIXME: identify orphaned modules and display them differently/separately.
	# Oprhaned modules are those that have been loaded, but now fail __syz::__is_loadable_dir.
	local -a _loaded
	__syz::__parse_list _loaded "$SYZ_MODULES"
	local _loaded_str
	__syz::__stringify_array -d "$__syz_nl" _loaded_str _loaded
	__syz::__columnate "Currently loaded modules" "No modules currently loaded." <<< "$_loaded_str"
}


function syz::inactive {
	local -a _loaded
	__syz::__parse_list _loaded "$SYZ_INACTIVE_MODULES"
	local _loaded_str
	__syz::__stringify_array -d "$__syz_nl" _loaded_str _loaded
	__syz::__columnate "Inactive modules" "No inactive modules." <<< "$_loaded_str"
}


function syz::load {
	local rc=0
	local i
	local _actually_loaded
	local _resolved_pv _resolved_dir
	for i; do
		# FIXME: strip any trailing "/*" when doing this check
		if __syz::__isloaded "$i" _actually_loaded; then
			# FIXME: maybe force reload (ie. unload then reload) it in this case?
			# FIXME: if already loaded, swap versions (ie. unload first)
			echo "Module $_actually_loaded is already loaded, skipping"
			continue
		fi

		if __syz::__resolve_loadable_dir "$i" _resolved_pv _resolved_dir; then
			echo "Loading $_resolved_pv from $_resolved_dir"
			# actually load it
			# FIXME: this should be a function
			# FIXME: use .syzrc if present
			# FIXME: use a .syzrc from the parent dir if present
			local subdir
			for subdir in "${__syz_subdirs[@]}"; do
				if [ -d "$_resolved_dir/$subdir" ]; then
					__syz::__process_dir load "$subdir" "$_resolved_dir/$subdir"
				fi
			done
			# remember that this is loaded
			append_path SYZ_MODULES "$_resolved_pv"
			append_path SYZ_MODULES_ABS "$_resolved_dir"
		else
			# FIXME: try to install it?
			echo "syz: No such module: $i"
			rc=1
		fi
	done
	return "$rc"
}


function syz::install {
	# FIXME: download binaries and put into place
	# FIXME: possibly compile
	:
}


function syz::isloaded {
	local i
	local _actually_loaded
	for i; do
		if __syz::__isloaded "$i" _actually_loaded; then
			echo "$_actually_loaded loaded"
		else
			echo "$i not loaded"
		fi
	done
}


function syz::unload {
	local rc=0
	local i
	local _actually_loaded
	local _resolved_pv _resolved_dir
	for i; do
		if ! __syz::__isloaded "$i" _actually_loaded; then
			echo "syz: Error: No module named $i is loaded"
			continue
		fi
		# use the full loaded module name. eg. mongodb/2.4.0 is loaded, user
		# does "unload mongodb", we need to be smart enough to figure out that
		# "mongodb/2.4.0" is what should be removed, not "mongodb" (which is
		# not a real/actual module name).

		# FIXME: do not search for the right dir. instead, use the dir from $SYZ_MODULES_ABS
		if __syz::__resolve_loadable_dir "$_actually_loaded" _resolved_pv _resolved_dir; then
			echo "Unloading $_resolved_pv from $_resolved_dir"
			# actually unload it
			# FIXME: this should be a function
			# FIXME: use .syzrc if present
			# FIXME: use a .syzrc from the parent dir if present
			local subdir
			for subdir in "${__syz_subdirs[@]}"; do
				# aggressively try to unload everything, even if the subdir doesn't actually exist anymore.
				__syz::__process_dir unload "$subdir" "$_resolved_dir/$subdir"
			done
			# forget that this was loaded
			remove_path SYZ_MODULES "$_resolved_pv"
			remove_path SYZ_MODULES_ABS "$_resolved_dir"
		else
			# YIKES
			# Module has been loaded, but now fails __syz::__is_loadable_dir.
			# This is an "orphaned" module.
			# The files have actually been removed from the previous location on disk, oh well, too bad so sad.
			#
			# This is similar to "inactive" modules.
			# This is where $SYZ_PATH has been adjusted such that the module can no longer be resolved.
			# The module gets auto-unloaded at that point, and moved from $SYZ_MODULES to $SYZ_INACTIVE_MODULES.
			# When $SYZ_PATH gets added to, any inactive modules that can now be resolved, will be auto loaded.
			echo "syz: No such module: $i"
			rc=1
		fi
	done
	return "$rc"
}


function syz::avail {
	# FIXME: accept an arg which is a prefix-match to limit things to (defaults to "")
	# FIXME: accept multiple args
	local basedir
	local -a _modules=()
	local -a _syz_path
	__syz::__parse_list _syz_path "$SYZ_PATH"
	if [ "$SYZ_PATH" ]; then
		__syz::__set_nullglob
		for basedir in "${_syz_path[@]}"; do
			local pkgdir
			for pkgdir in "$basedir"/*; do
				local pkgname="${pkgdir#$basedir/}"

				# check for current and default
				local current=""
				if [ -L "$pkgdir/current" ]; then
					local currentdir="$(readlink -f "$pkgdir/current")"
					if [ -d "$currentdir" ]; then
						current="$(readlink "$pkgdir/current")"
					fi
				fi

				local default=""
				if [ -L "$pkgdir/default" ]; then
					local defaultdir="$(readlink -f "$pkgdir/default")"
					if [ -d "$defaultdir" ]; then
						default="$(readlink "$pkgdir/default")"
					fi
				fi

				local versiondir
				for versiondir in "$pkgdir"/*; do
					local version="${versiondir#$pkgdir/}"

					if __syz::__fancy_output; then
						if [ "$version" = current -a "$current" ]; then
							: # ignore
						elif [ "$version" = default -a "$default" ]; then
							: # ignore
						elif __syz::__is_loadable_dir "$versiondir"; then
							local suffix=""
							if [ "$current" = "$version" ]; then
								suffix+=" (current)"
							elif [ "$default" = "$version" ]; then
								suffix+=" (default)"
							fi
							_modules+=("$pkgname/$version$suffix")
						else
							# not loadable
							: # ignore
						fi
					else
						if __syz::__is_loadable_dir "$versiondir"; then
							_modules+=("$pkgname/$version")
						fi
					fi
				done
			done
		done
		__syz::__restore_nullglob
	fi
	local _str
	__syz::__stringify_array -d "$__syz_nl" _str _modules
	__syz::__columnate "Available modules" "No modules available." <<< "$_str"
}


function syz::reload {
	# FIXME: ideally clean up and remove all the private functions also
	local src="$SYZ_SOURCE"
	unset SYZ_SOURCE
	. "$src"
}


function syz::version {
	echo "syz version $SYZ_VERSION"
}




##################################################
##
##  Interface (syzrc) functions
##
##################################################


function prepend_path {
	__syz::__adjust_list_var prepend : "$@"
}


function append_path {
	__syz::__adjust_list_var append : "$@"
}


function bin_dir {
	#prepend_path PATH "$@"
	#FIXME: deal better with $mode
	__syz::__process_dir "$mode" bin "$@"
}

function remove_path {
	__syz::__remove_list_var : "$@"
}




##################################################
##
##  Internal functions
##
##################################################


function __syz::__rerun_if_updated {
	# FIXME: use a hash of the file contents instead
	local modtime="$(stat -L -c '%Y' "$SYZ_SOURCE")"
	if [ "$SYZ_SOURCED_AT" -a "$modtime" -a "$modtime" -gt "$SYZ_SOURCED_AT" ]; then
		echo "syz: updated, auto-reloading..." 1>&2
		echo 1>&2
		syz::reload
		# FIXME: the re-call of self should be done by the caller, who can simply do "$0" "$@"
		syz "$@"
		return 0
	fi
	return 1
}


function __syz::__process_dir {
	local mode="$1" ; shift
	local type="$1" ; shift
	case "$mode" in
		load)
			case "$type" in
				bin)
					prepend_path PATH "$@"
					;;
				lib)
					;;
				share/man|man)
					;;
				share/pkgconfig)
					;;
				sw)
					;;
			esac
			;;
		unload)
			case "$type" in
				bin)
					remove_path PATH "$@"
					;;
				lib)
					;;
				share/man|man)
					;;
				share/pkgconfig)
					;;
				sw)
					;;
			esac
			;;
	esac
}


function __syz::__isloaded {
	local looking_for="$1" ; shift
	local ${1+-n} found="$1" ; shift
	local -a _loaded
	__syz::__parse_list _loaded "$SYZ_MODULES"
	local i
	local rc=1
	for i in "${_loaded[@]}"; do
		case "$i" in
			"$looking_for"|"$looking_for"/*)
				found="$i"
				rc=0
				break
				;;
		esac
	done
	return "$rc"
}


function __syz::__resolve_loadable_dir {
	# FIXME: if no trailing "/<version>", then figure out and use the default version
	local target="$1" ; shift
	local ${1+-n} output_pv="$1" ; shift   # "pv" == "<pkgname>/<version>"
	local ${1+-n} output_dir="$1" ; shift
	local basedir
	local rc=1
	local -a _syz_path
	__syz::__parse_list _syz_path "$SYZ_PATH"
	if [ "$SYZ_PATH" ]; then
		__syz::__set_nullglob
		for basedir in "${_syz_path[@]}"; do
			if __syz::__is_loadable_dir "$basedir/$target"; then
				output_pv="$target"
				output_dir="$basedir/$target"
				rc=0
				break
			fi
		done
		__syz::__restore_nullglob
	fi
	return "$rc"
}


declare -a __syz_nullglob_stack

function __syz::__set_nullglob {
	__syz_nullglob_stack+=("$(shopt -p nullglob || true)")
	shopt -s nullglob
}


function __syz::__restore_nullglob {
	eval "${__syz_nullglob_stack[${#__syz_nullglob_stack[@]}-1]}"
	unset __syz_nullglob_stack[${#__syz_nullglob_stack[@]}-1]
}


function __syz::__fancy_output {
	# FIXME: allow the user to override
	# Fancy output for terminals, plain otherwise
	tty -s 0<&1
}

function __syz::__columnate {
	local header="$1" ; shift
	local emptymsg="$1" ; shift
	local output="$(cat "$@")"
	if __syz::__fancy_output; then
		if [ "$output" ]; then
			if [ "$header" ]; then
				echo
				echo "$header"
				echo "${header//?/-}-"
				echo
			fi
			local numlines=0
			local dummy
			while read dummy; do
				numlines=$(($numlines + 1))
			done <<< "$output"
			awk -v numlines="$numlines" 'NF > 0 { printf("%"length(numlines)"s) %s\n", NR, $0); }' <<< "$output" | column
			if [ "$header" ]; then
				echo
			fi
		else
			if [ "$emptymsg" ]; then
				echo "$emptymsg"
				echo
			fi
		fi
	else
		if [ "$output" ]; then
			echo "$output"
		fi
	fi
}


function __syz::__is_loadable_dir {
	# check for a valid subdir or .syzrc
	# FIXME: .syzrc in the parent dir is also acceptable
	if [ -r "$1/.syzrc" ]; then
		return 0
	fi
	local i
	for i in "${__syz_subdirs[@]}"; do
		if [ -d "$1/$i" ]; then
			return 0
		fi
	done
	return 1
}


function __syz::__parse_list {
	local delim=:
	if [ x"$1" = x"-d" ]; then
		delim="$2"
		shift 2
	fi
	local -n output="$1" ; shift
	local old_IFS="$IFS"
	IFS="$delim"
	output=()
	local i
	for i in $1; do
		output+=("$i")
	done
	local rc="$?"
	IFS="$old_IFS"
	return "$rc"
}


function __syz::__stringify_array {
	local delim=:
	if [ x"$1" = x"-d" ]; then
		delim="$2"
		shift 2
	fi
	local -n output="$1" ; shift
	local -n array="$1" ; shift
	local old_IFS="$IFS"
	IFS="$delim"
	output="${array[*]}"
	local rc="$?"
	IFS="$old_IFS"
	return "$rc"
}


function __syz::__absolutify {
	echo "$1"
}


function __syz::__adjust_list_var {
	local type="$1" ; shift
	local sep="$1" ; shift
	local var="$1" ; shift
	local i
	for i; do
		i="$(__syz::__absolutify "$i")"
		case "${!var}" in
			*"$sep$i$sep"*)  ;;  # Already present
			     "$i$sep"*)  ;;  # Already present
			*"$sep$i")       ;;  # Already present
			     "$i")       ;;  # Already present
			*)
				case "$type" in
					prepend) declare -gx "$var"="$i${!var:+$sep}${!var}" ;;
					append)  declare -gx "$var"="${!var}${!var:+$sep}$i" ;;
				esac
				;;
		esac
	done
}


function __syz::__remove_list_var {
	local sep="$1" ; shift
	local var="$1" ; shift
	local i
	for i; do
		i="$(__syz::__absolutify "$i")"
		case "${!var}" in
			*"$sep$i$sep"*) declare -gx "$var"="${!var/$sep$i$sep/$sep}" ;;
			     "$i$sep"*) declare -gx "$var"="${!var/#$i$sep}" ;;
			*"$sep$i")      declare -gx "$var"="${!var/%$sep$i}" ;;
			     "$i")      declare -gx "$var"="" ;;
			*)  ;;  # Not present
		esac
	done
}




##################################################
##
##  Setup (remaining) external variables
##
##################################################


if [ "${SYZ_PATH+set}" != set ]; then
	SYZ_PATH="/sw"
	declare -x SYZ_PATH
fi

if [ "${SYZ_MODULES+set}" != set ]; then
	SYZ_MODULES=""
	declare -x SYZ_MODULES
	SYZ_MODULES_ABS=""
	declare -x SYZ_MODULES_ABS
	SYZ_INACTIVE_MODULES=""
	declare -x SYZ_INACTIVE_MODULES
fi



##################################################
##
##  Setup internal variables
##
##################################################


__syz_nl='
'


declare -a __syz_subdirs
__syz_subdirs+=(bin)
__syz_subdirs+=(lib)
__syz_subdirs+=(man)
__syz_subdirs+=(share/man)
__syz_subdirs+=(share/pkgconfig)
__syz_subdirs+=(sw)



# FIXME: source user's ~/.syzrc, if present


