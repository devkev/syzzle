#!/bin/bash

#
# Functional and unit tests for syz
#


if [ "$1" != real ]; then
	unset SYZ_{PATH,MODULES,MODULES_ABS,INACTIVE_MODULES}
	exec bash --norc "$0" real
fi

# Setup

basedir=""
trap 'rc="$?" ; set +ex ; if [ $rc = 0 ]; then echo "ALL TESTS PASSED"; else echo "TEST FAILED ($rc)"; fi ; [ "$basedir" ] && rm -rf "$basedir" ; exit $rc' EXIT
basedir="$(mktemp -d)"
pipe="$basedir/pipe"
mkfifo "$pipe"

nl='
'
test_pvs=""
for i in {abc,def,ghi,jkl}/{1.0,1.1,1.2,1.3}; do
	mkdir -p "$basedir/sw/$i"/{bin,lib}
	test_pvs="$test_pvs$i$nl"
done
test_pvs="${test_pvs%$nl}"
echo "$test_pvs"
export SYZ_PATH="$basedir/sw"


function run {
	echo "+ ${FUNCNAME[0]} $*"
	# FIXME: crap crap crap, need to capture output without spawning a subshell
	#exec 3>&1
	{
	# This approach doesn't work - the & causes a subshell, which is where o gets set (not here).
	# Just mkfifo inside $basedir and use that.
	# Named pipe won't work because it can't be read in the background (as above), and the pipes
	# can only buffer so much data before they'll block.
	# So just use a temp file.
	o="$(cat 0<&3)" &
	"$@" 3>&1
	} 3>&1
	rc="$?"
	wait
}

function run_tty {
	echo "+ ${FUNCNAME[0]} $*"
	function tty {
		:
	}
	# FIXME: crap crap crap, need to capture output without spawning a subshell
	o="$("$@")"
	rc="$?"
	unset -f tty
}


function check {
	local what="$1" ; shift
	set -e
	check_"$what" "$@"
	set +e
}

function check_success {
	echo "++ ${FUNCNAME[0]}"
	[ "$rc" = "0" ]
}

function check_failure {
	local code="$1" ; shift
	echo "++ ${FUNCNAME[0]} $code"
	if [ "$code" ]; then
		[ "$rc" = "$code" ]
	else
		[ "$rc" != "0" ]
	fi
}

function check_output_pattern {
	local i
	for i; do
		echo "++ ${FUNCNAME[0]} $i"
		grep -q "$i" <<<"$o"
	done
}

function check_output_exact {
	local target="$1" ; shift
	echo "++ ${FUNCNAME[0]}"
	[ "$o" = "$target" ]
}

function check_envvar_pattern {
	local var="$1" ; shift
	local pattern="$1" ; shift
	local -n value="$var"
	echo "++ ${FUNCNAME[0]} $var $pattern"
	grep -q "$pattern" <<<"$value"
}

function check_envvar_exact {
	local var="$1" ; shift
	local target="$1" ; shift
	local -n value="$var"
	echo "++ ${FUNCNAME[0]} $var"
	[ "$value" = "$target" ]
}

function check_envvar_set {
	local i
	for i; do
		echo "++ ${FUNCNAME[0]} $i"
		[ "${!i+set}" = "set" ]
	done
}

function check_envvar_unset {
	local i
	for i; do
		echo "++ ${FUNCNAME[0]} $i"
		[ "${!i+set}" != "set" ]
	done
}

echo "+ prelim"
check envvar_pattern "SYZ_PATH" '^'"$basedir"'/sw$'
check envvar_unset SYZ_{MODULES,MODULES_ABS,INACTIVE_MODULES}

set -e
. ./syzzle
set +e

check envvar_pattern "SYZ_VERSION" '.'
check envvar_pattern "SYZ_PATH" '^'"$basedir"'/sw$'
check envvar_set SYZ_{MODULES,MODULES_ABS,INACTIVE_MODULES}
check envvar_exact "SYZ_MODULES" ''
check envvar_exact "SYZ_MODULES_ABS" ''
check envvar_exact "SYZ_INACTIVE_MODULES" ''

run syz version
check success
check output_pattern "version" "$SYZ_VERSION"

run syz loaded
check success
check output_exact ""
run_tty syz loaded
check success
check output_pattern 'No modules currently loaded\.'

run syz inactive
check success
check output_exact ""
run_tty syz inactive
check success
check output_pattern 'No inactive modules\.'

run syz empty
check success
o_empty="$o"
run syz
check success
check output_exact "$o_empty"

run syz show
check success
o_show="$o"
run syz status
check success
check output_exact "$o_show"

run syz avail
check success
check output_exact "$test_pvs"

run syz load abc/1.0
check success
check output_pattern 'Loading' 'abc/1.0'
echo "$SYZ_MODULES"
check envvar_pattern 'SYZ_MODULES' 'abc/1.0'
check envvar_pattern 'SYZ_MODULES_ABS' "$basedir"/sw/abc/1.0
check envvar_pattern 'PATH' "$basedir"/sw/abc/1.0/bin






